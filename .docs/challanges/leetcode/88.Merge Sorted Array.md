# 88. Merge Sorted Array

## Problem Description

You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

Merge `nums1` and `nums2` into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to 0 and should be ignored. `nums2` has a length of `n`.

## Examples

### Example 1

**Input:** `nums1 = [1,2,3,0,0,0]`, `m = 3`, `nums2 = [2,5,6]`, `n = 3`
**Output:** `[1,2,2,3,5,6]`
**Explanation:** The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

### Example 2

**Input:** `nums1 = [1]`, `m = 1`, `nums2 = []`, `n = 0`
**Output:** `[1]`
**Explanation:** The arrays we are merging are [1] and []. The result of the merge is [1].

### Example 3

**Input:** `nums1 = [0]`, `m = 0`, `nums2 = [1]`, `n = 1`
**Output:** `[1]`
**Explanation:** The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

## Constraints

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

## Solution

### Algorithm Explanation

**Approach:** Three-pointer technique with reverse iteration (merge from end to beginning)

The key insight is to merge the arrays from **right to left** instead of left to right. Since `nums1` already has enough space at the end, we can fill it from the back without overwriting any unprocessed elements.

**Why merge from the end?**
- If we merge from the beginning, we'd need extra space or risk overwriting unprocessed elements in `nums1`
- Merging from the end uses the existing space in `nums1` efficiently
- No additional space needed (in-place modification)

**Steps:**
1. Initialize three pointers:
   - `p1` = `m - 1` (last valid element in nums1)
   - `p2` = `n - 1` (last element in nums2)
   - `p` = `m + n - 1` (last position in nums1 where we'll place elements)
2. Compare elements at `p1` and `p2`:
   - Place the larger element at position `p`
   - Move the corresponding pointer and `p` backwards
3. Continue until all elements from `nums2` are processed
4. If elements remain in `nums1`, they're already in correct position
5. If elements remain in `nums2`, copy them to the beginning of `nums1`

**Complexity:**
- **Time Complexity:** O(m + n) - visit each element once
- **Space Complexity:** O(1) - in-place modification, no extra space needed

**Edge Cases:**
- `nums2` is empty: `nums1` already sorted
- `nums1` is empty (m = 0): copy all of `nums2` to `nums1`
- All elements in `nums2` are larger: fill from the end
- All elements in `nums2` are smaller: copy to the beginning

### C# Implementation

```csharp
public class C88MergeSortedArray
{
    public void Merge(int[] nums1, int m, int[] nums2, int n)
    {
        // Three pointers: p1 for nums1, p2 for nums2, p for placement position
        int p1 = m - 1;      // Last valid element in nums1
        int p2 = n - 1;      // Last element in nums2
        int p = m + n - 1;   // Last position in nums1 (where we place elements)

        // Merge from right to left
        while (p1 >= 0 && p2 >= 0)
        {
            // Compare and place the larger element at position p
            if (nums1[p1] > nums2[p2])
            {
                nums1[p] = nums1[p1];
                p1--;
            }
            else
            {
                nums1[p] = nums2[p2];
                p2--;
            }
            p--;
        }

        // If elements remain in nums2, copy them to nums1
        // (If elements remain in nums1, they're already in correct position)
        while (p2 >= 0)
        {
            nums1[p] = nums2[p2];
            p2--;
            p--;
        }
    }
}
```

**Key Insights:**
- Merging from the end avoids the need for extra space
- The three-pointer technique elegantly handles the in-place requirement
- We only need to copy remaining `nums2` elements because remaining `nums1` elements are already in place
- This is a classic example of the two-pointer technique adapted for merging sorted arrays
