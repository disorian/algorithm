# 169. Majority Element

**Problem Link**: <https://leetcode.com/problems/majority-element/description/>

## Problem Description

Given an array `nums` of size `n`, return the majority element.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

## Examples

### Example 1

**Input**: `nums = [3,2,3]`

**Output**: `3`

### Example 2

**Input**: `nums = [2,2,1,1,1,2,2]`

**Output**: `2`

## Constraints

- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`
- The input is generated such that a majority element will exist in the array

## Follow-up

Could you solve the problem in linear time and in `O(1)` space?

## Solution

### Algorithm Explanation

**Approach:** Boyer-Moore Voting Algorithm

This problem can be solved optimally using the Boyer-Moore Voting Algorithm, which finds the majority element in `O(n)` time and `O(1)` space. The algorithm is based on the insight that if we cancel out each occurrence of an element with all the other elements that are different from it, the majority element will still remain.

**How It Works:**

The algorithm maintains two variables:
1. **Candidate**: A potential majority element
2. **Count**: How many times we've seen this candidate (net of cancellations)

**Steps:**
1. Initialise `candidate` to any value and `count` to `0`
2. Iterate through each element in the array:
   - If `count == 0`, set `candidate` to the current element
   - If the current element equals `candidate`, increment `count`
   - If the current element differs from `candidate`, decrement `count`
3. Return `candidate` (guaranteed to be the majority element)

**Why This Works - Detailed Explanation:**

The brilliance of this algorithm lies in its cancellation strategy. Here's the key insight:

**Mathematical Proof:**
- The majority element appears more than `⌊n / 2⌋` times
- All other elements combined appear less than `⌊n / 2⌋` times
- If we pair up each majority element with a non-majority element and eliminate both, the majority element will always have leftover occurrences

**Detailed Mechanics:**

1. **The Count Variable as a Balance:**
   - Think of `count` as a score or weight for the current candidate
   - When we see our candidate, we add +1 (evidence this is the majority)
   - When we see a different element, we add -1 (evidence against our candidate)
   - When count reaches 0, we've seen equal numbers of our candidate and other elements

2. **Why Changing Candidates is Safe:**
   - When `count` reaches 0, we've effectively "cancelled out" equal numbers of different elements
   - These cancelled elements can be removed from consideration - they don't affect the final answer
   - In the remaining subarray, the majority element is still the majority
   - We can safely pick a new candidate from the remaining elements

3. **The Invariant:**
   - At any point, if we removed all the cancelled-out pairs, the majority element would still be the majority in what remains
   - The final candidate is the one that survives all cancellations
   - Since the majority element appears more than n/2 times, it mathematically cannot be fully cancelled

**Concrete Example with Detailed Tracking:**

```
nums = [7, 7, 5, 7, 5, 1, 5, 7, 5, 5, 7, 7] (length=12, majority needs >6 occurrences)
7 appears 6 times, 5 appears 5 times, 1 appears 1 time
Wait - this doesn't have a majority! Let's use a valid example:

nums = [7, 7, 5, 7, 5, 1, 5, 7, 7, 7, 7] (length=11, majority needs >5.5 = 6 occurrences)
7 appears 7 times (majority ✓), 5 appears 3 times, 1 appears 1 time

Step-by-step execution:
Index | Element | Before          | Action                    | After
------|---------|-----------------|---------------------------|------------------
  0   |    7    | count=0, cand=? | count=0, new candidate    | count=1, cand=7
  1   |    7    | count=1, cand=7 | match, increment          | count=2, cand=7
  2   |    5    | count=2, cand=7 | different, decrement      | count=1, cand=7
  3   |    7    | count=1, cand=7 | match, increment          | count=2, cand=7
  4   |    5    | count=2, cand=7 | different, decrement      | count=1, cand=7
  5   |    1    | count=1, cand=7 | different, decrement      | count=0, cand=7
  6   |    5    | count=0, cand=7 | count=0, new candidate    | count=1, cand=5
  7   |    7    | count=1, cand=5 | different, decrement      | count=0, cand=5
  8   |    7    | count=0, cand=5 | count=0, new candidate    | count=1, cand=7
  9   |    7    | count=1, cand=7 | match, increment          | count=2, cand=7
 10   |    7    | count=2, cand=7 | match, increment          | count=3, cand=7

Result: candidate=7, count=3 → Answer: 7 ✓
```

**Why It Works Even with Candidate Changes:**
- At index 5, we've cancelled out: one 7+5 pair, one 7+5 pair, one 7+1 pair
- Removed: [7,7,5,5,1,7], Remaining: [7,5,7,7,7]
- In the remaining array, 7 appears 4 times out of 5 - still the majority!
- The algorithm continues with a clean slate and finds the true majority

**Key Properties:**
1. **Resilience**: The majority element will survive because there are more of them than all others combined
2. **Efficiency**: We only need one pass and constant space
3. **Simplicity**: The algorithm is remarkably simple for such an elegant solution
4. **Generality**: Works for any array where a majority element exists

**Common Misconceptions:**
- ❌ "The final candidate must be the first element we see most often" - No! We may change candidates multiple times
- ❌ "We need to verify the candidate" - Not for this problem, since majority is guaranteed
- ❌ "The count tells us the actual frequency" - No! Count only tells us the current balance, not total occurrences
- ✅ "The algorithm guarantees finding the majority if one exists with >n/2 occurrences"

**Intuition:**
- Think of it as a "voting" system where different elements cancel each other out
- The majority element will always "survive" because there are more of them than all other elements combined
- When `count` reaches `0`, we've cancelled out equal numbers of different elements
- The final `candidate` is the one that couldn't be fully cancelled

**Complexity:**
- **Time Complexity:** O(n) - Single pass through the array
- **Space Complexity:** O(1) - Only two variables regardless of input size

**Alternative Approaches:**

1. **HashMap Counting** - O(n) time, O(n) space: Count frequencies and return element with count > n/2
2. **Sorting** - O(n log n) time, O(1) space: Sort and return middle element (always majority)
3. **Divide and Conquer** - O(n log n) time, O(log n) space: Recursively find majority in halves

The Boyer-Moore algorithm is optimal for both time and space.

**Edge Cases:**
- Single element: `[5]` → `5`
- All same elements: `[7,7,7,7,7]` → `7`
- Majority at minimum count: `[1,2,1]` → `1` (appears 2 times out of 3)
- Large arrays with alternating elements: Still finds majority efficiently

### C# Implementation

#### Solution 1: Boyer-Moore Voting Algorithm (Optimal) ✅

**Time:** O(n) | **Space:** O(1)

```csharp
public int MajorityElement(int[] nums)
{
    int candidate = 0;
    int count = 0;

    foreach (int num in nums)
    {
        // When count reaches 0, select new candidate
        if (count == 0)
        {
            candidate = num;
        }

        // Increment if matches candidate, decrement otherwise
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}
```

#### Solution 2: HashMap/Dictionary Counting

**Time:** O(n) | **Space:** O(n)

This approach is more intuitive - count the frequency of each element and return the one that appears more than n/2 times.

```csharp
public int MajorityElement_HashMap(int[] nums)
{
    Dictionary<int, int> counts = [];
    int majorityThreshold = nums.Length / 2;

    foreach (int num in nums)
    {
        counts[num] = counts.GetValueOrDefault(num, 0) + 1;

        // Return as soon as we find element with > n/2 occurrences
        if (counts[num] > majorityThreshold)
        {
            return num;
        }
    }

    return -1;
}
```

**Pros:**
- Easy to understand and implement
- Can be modified to find all elements with specific frequency thresholds
- Early termination when majority is found

**Cons:**
- Uses O(n) extra space for the dictionary
- Slower than Boyer-Moore due to dictionary operations

#### Solution 3: Sorting

**Time:** O(n log n) | **Space:** O(1) or O(n) depending on sort

This solution relies on a clever insight: if an element appears more than n/2 times, it must occupy the middle position after sorting.

```csharp
public int MajorityElement_Sorting(int[] nums)
{
    Array.Sort(nums);

    // The middle element must be the majority element
    return nums[nums.Length / 2];
}
```

**Why the middle element works:**
```
Example: [2,2,1,1,1,2,2] (length 7, need >3 occurrences)
After sorting: [1,1,1,2,2,2,2]
Middle index: 7/2 = 3
Element at index 3: 2 ✓

Consider any position of majority element:
- If majority element starts at index 0, it extends past middle (>n/2 length)
- If majority element ends at index n-1, it starts before middle (>n/2 length)
- If majority element is in middle, it clearly includes middle position
- Therefore, middle position ALWAYS contains majority element
```

**Pros:**
- Extremely simple - just 2 lines of code
- Easy to verify correctness
- No additional data structures needed

**Cons:**
- Slower O(n log n) time complexity
- Modifies the input array (unless you make a copy)

#### Solution 4: Divide and Conquer

**Time:** O(n log n) | **Space:** O(log n) for recursion stack

This solution recursively finds the majority in the left and right halves, then combines the results.

```csharp
public int MajorityElement_DivideConquer(int[] nums)
{
    return MajorityElementRecursive(nums, 0, nums.Length - 1);
}

private int MajorityElementRecursive(int[] nums, int left, int right)
{
    // Base case: single element
    if (left == right)
    {
        return nums[left];
    }

    // Divide
    int mid = left + (right - left) / 2;

    // Conquer: find majority in both halves
    int leftMajority = MajorityElementRecursive(nums, left, mid);
    int rightMajority = MajorityElementRecursive(nums, mid + 1, right);

    // If both agree, return it
    if (leftMajority == rightMajority)
    {
        return leftMajority;
    }

    // Combine: count which candidate appears more in full range
    int leftCount = CountInRange(nums, leftMajority, left, right);
    int rightCount = CountInRange(nums, rightMajority, left, right);

    return leftCount > rightCount ? leftMajority : rightMajority;
}

private int CountInRange(int[] nums, int target, int left, int right)
{
    int count = 0;
    for (int i = left; i <= right; i++)
    {
        if (nums[i] == target)
        {
            count++;
        }
    }
    return count;
}
```

**How it works:**
1. **Base case:** A single element is always the majority of itself
2. **Divide:** Split array into two halves
3. **Conquer:** Find majority element in each half recursively
4. **Combine:**
   - If both halves have the same majority, that's the answer
   - Otherwise, count both candidates in the full range and return the one with more occurrences

**Pros:**
- Demonstrates divide-and-conquer problem-solving
- Doesn't modify input array
- Educational value for understanding recursion

**Cons:**
- More complex than other solutions
- O(n log n) time due to counting in combine step
- Uses extra space for recursion stack

### Comparison Summary

| Solution | Time | Space | Pros | Cons | Best For |
|----------|------|-------|------|------|----------|
| **Boyer-Moore** | O(n) | O(1) | Optimal, elegant | Less intuitive | Production code ✅ |
| **HashMap** | O(n) | O(n) | Intuitive, flexible | Extra space | Learning, debugging |
| **Sorting** | O(n log n) | O(1)* | Simple, 2 lines | Slower, modifies input | Quick implementation |
| **Divide & Conquer** | O(n log n) | O(log n) | Educational | Complex, slower | Learning recursion |

*Space complexity depends on sorting algorithm implementation

**Recommendation:** Use Boyer-Moore for production. Use HashMap for interviews if you want to play it safe with an easier-to-explain solution.

**Key Insights:**
- No need to verify the candidate at the end because the problem guarantees a majority element exists
- The algorithm works even when elements are negative or zero
- The `count` variable tracks the "strength" of the current candidate
- When `count` becomes `0`, we've seen equal numbers of the candidate and other elements
- The final candidate is guaranteed to be the majority because it appears more than `n/2` times
- This is a perfect example of a greedy algorithm that makes optimal local choices leading to a global solution

**Visual Example:**
```
nums = [2,2,1,1,1,2,2]

Step-by-step:
i=0: num=2, count=0 → candidate=2, count=1
i=1: num=2, count=1 → candidate=2, count=2
i=2: num=1, count=2 → candidate=2, count=1 (different, decrement)
i=3: num=1, count=1 → candidate=2, count=0 (different, decrement)
i=4: num=1, count=0 → candidate=1, count=1 (new candidate)
i=5: num=2, count=1 → candidate=1, count=0 (different, decrement)
i=6: num=2, count=0 → candidate=2, count=1 (new candidate)

Result: 2
```