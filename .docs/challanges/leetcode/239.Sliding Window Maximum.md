# 239. Sliding Window Maximum

**Difficulty**: Hard
**Topics**: Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue
**LeetCode Link**: https://leetcode.com/problems/sliding-window-maximum/

---

## Problem Description

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.

### Example 1:

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

### Example 2:

```
Input: nums = [1], k = 1
Output: [1]
```

### Example 3:

```
Input: nums = [1,-1], k = 1
Output: [1,-1]
```

### Example 4:

```
Input: nums = [9,11], k = 2
Output: [11]
```

### Example 5:

```
Input: nums = [4,-2], k = 2
Output: [4]
```

### Constraints:

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

---

## Understanding Deque

**Deque** is pronounced **"deck"** (like a deck of cards), not "de-queue".

### What is a Deque?

**Deque** stands for **"Double-Ended Queue"** - a data structure that allows insertion and deletion at **both ends** (front and back).

#### Operations:

```csharp
// Deque operations:
- AddFirst() / AddLast()       // Insert at front/back - O(1)
- RemoveFirst() / RemoveLast() // Remove from front/back - O(1)
- First / Last                 // View front/back - O(1)
```

#### In C#:

C# doesn't have a built-in `Deque` class, but **`LinkedList<T>`** provides all deque operations:

```csharp
var deque = new LinkedList<int>();

// Add to ends
deque.AddFirst(1);  // Front: [1]
deque.AddLast(2);   // [1, 2]
deque.AddLast(3);   // [1, 2, 3]

// Remove from ends
deque.RemoveFirst();  // [2, 3]
deque.RemoveLast();   // [2]

// Peek at ends
int first = deque.First!.Value;  // 2
int last = deque.Last!.Value;    // 2
```

---

## Solution Approach: Monotonic Deque

### The Core Idea

The deque maintains **indices** of elements in **decreasing order of their values**. This means:
- **Front of deque** = index of the largest element in current window
- **Back of deque** = index of the smallest element we're keeping

### Why Can We Remove Elements?

**Key insight**: If we're at position `i` and `nums[i]` is larger than `nums[j]` where `j < i`, we can **discard `j` forever** because:
1. `nums[i]` is larger
2. `nums[i]` will stay in windows longer (it came later)

### The Two Key Operations

#### 1. Remove from Front (Outside Window)
```csharp
// Remove indices that have left the window
while (deque.Count > 0 && deque.First!.Value <= i - k)
{
    deque.RemoveFirst();
}
```

#### 2. Remove from Back (Maintain Decreasing Order)
```csharp
// Remove smaller elements (they'll never be max)
while (deque.Count > 0 && nums[deque.Last!.Value] < nums[i])
{
    deque.RemoveLast();
}
```

---

## Step-by-Step Example

### Example: `nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3`

```
Initial: deque = [], result = []

Step i=0: nums[0] = 1
  - deque is empty, add index 0
  - deque = [0]  (values: [1])
  - Window not complete yet

Step i=1: nums[1] = 3
  - Check back: nums[1]=3 > nums[0]=1
  - Remove index 0 (1 will never be max again!)
  - Add index 1
  - deque = [1]  (values: [3])
  - Window not complete yet

Step i=2: nums[2] = -1
  - Check back: nums[2]=-1 < nums[1]=3
  - Keep both! -1 might be max in future windows
  - Add index 2
  - deque = [1, 2]  (values: [3, -1])
  - ✓ Window complete! [1, 3, -1]
  - Max = nums[deque.First] = nums[1] = 3
  - result[0] = 3

Step i=3: nums[3] = -3
  - Remove indices outside window: 0 is at i-k = 3-3 = 0, but deque.First=1, ok
  - Check back: nums[3]=-3 < nums[2]=-1
  - Add index 3
  - deque = [1, 2, 3]  (values: [3, -1, -3])
  - Window [3, -1, -3]
  - Max = nums[1] = 3
  - result[1] = 3

Step i=4: nums[4] = 5
  - Remove indices ≤ i-k: 4-3=1, deque.First=1, REMOVE IT!
  - deque = [2, 3]  (values: [-1, -3])
  - Check back: nums[4]=5 > nums[3]=-3, REMOVE 3
  - deque = [2]  (values: [-1])
  - Check back: nums[4]=5 > nums[2]=-1, REMOVE 2
  - deque = []
  - Add index 4
  - deque = [4]  (values: [5])
  - Window [-1, -3, 5]
  - Max = nums[4] = 5
  - result[2] = 5

Step i=5: nums[5] = 3
  - Check window: 5-3=2, deque.First=4, ok
  - Check back: nums[5]=3 < nums[4]=5
  - Add index 5
  - deque = [4, 5]  (values: [5, 3])
  - Window [-3, 5, 3]
  - Max = nums[4] = 5
  - result[3] = 5

Step i=6: nums[6] = 6
  - Check window: 6-3=3, deque.First=4, ok
  - Check back: nums[6]=6 > nums[5]=3, REMOVE 5
  - deque = [4]  (values: [5])
  - Check back: nums[6]=6 > nums[4]=5, REMOVE 4
  - deque = []
  - Add index 6
  - deque = [6]  (values: [6])
  - Window [5, 3, 6]
  - Max = nums[6] = 6
  - result[4] = 6

Step i=7: nums[7] = 7
  - Check window: 7-3=4, deque.First=6, ok
  - Check back: nums[7]=7 > nums[6]=6, REMOVE 6
  - deque = []
  - Add index 7
  - deque = [7]  (values: [7])
  - Window [3, 6, 7]
  - Max = nums[7] = 7
  - result[5] = 7

Final result = [3, 3, 5, 5, 6, 7] ✓
```

### Visual Representation

```
        Deque State (showing indices)
        [Front ... Back]

i=0:    [0]           → values: [1]
i=1:    [1]           → values: [3]        (removed 0)
i=2:    [1, 2]        → values: [3, -1]
i=3:    [1, 2, 3]     → values: [3, -1, -3]
i=4:    [4]           → values: [5]        (removed 1,2,3)
i=5:    [4, 5]        → values: [5, 3]
i=6:    [6]           → values: [6]        (removed 4,5)
i=7:    [7]           → values: [7]        (removed 6)
```

---

## Additional Examples

### Example 2: Decreasing Array

```
nums = [5, 4, 3, 2, 1], k = 3

i=0: deque=[0]           values=[5]
i=1: deque=[0,1]         values=[5,4]       (4 < 5, keep both)
i=2: deque=[0,1,2]       values=[5,4,3]     (3 < 4, keep all)
     Window [5,4,3], max=5 ✓

i=3: deque=[1,2,3]       values=[4,3,2]     (removed 0, outside window)
     Window [4,3,2], max=4 ✓

i=4: deque=[2,3,4]       values=[3,2,1]     (removed 1, outside window)
     Window [3,2,1], max=3 ✓

Result: [5, 4, 3]
```

**Why keep all elements?** When array is decreasing, each element might become max when earlier elements leave the window!

### Example 3: Increasing Array

```
nums = [1, 2, 3, 4, 5], k = 3

i=0: deque=[0]           values=[1]
i=1: deque=[1]           values=[2]         (removed 0: 2>1)
i=2: deque=[2]           values=[3]         (removed 1: 3>2)
     Window [1,2,3], max=3 ✓

i=3: deque=[3]           values=[4]         (removed 2: 4>3)
     Window [2,3,4], max=4 ✓

i=4: deque=[4]           values=[5]         (removed 3: 5>4)
     Window [3,4,5], max=5 ✓

Result: [3, 4, 5]
```

**Deque always has 1 element!** Each new element removes all previous ones because it's larger.

### Example 4: All Same Values

```
nums = [3, 3, 3, 3, 3], k = 3

i=0: deque=[0]           values=[3]
i=1: deque=[0,1]         values=[3,3]       (3==3, keep both)
i=2: deque=[0,1,2]       values=[3,3,3]     (3==3, keep all)
     Window [3,3,3], max=3 ✓

i=3: deque=[1,2,3]       values=[3,3,3]     (removed 0)
     Window [3,3,3], max=3 ✓

i=4: deque=[2,3,4]       values=[3,3,3]     (removed 1)
     Window [3,3,3], max=3 ✓

Result: [3, 3, 3]
```

---

## Implementation

```csharp
public int[] MaxSlidingWindow(int[] nums, int k)
{
    if (nums.Length == 0 || k == 0) return Array.Empty<int>();

    int[] result = new int[nums.Length - k + 1];
    var deque = new LinkedList<int>(); // Stores indices

    for (int i = 0; i < nums.Length; i++)
    {
        // 1. Remove indices outside the current window (from front)
        //    If the front index is <= i-k, it's outside the window
        while (deque.Count > 0 && deque.First!.Value <= i - k)
        {
            deque.RemoveFirst();
        }

        // 2. Remove indices of smaller elements (from back)
        //    They will never be the maximum in current or future windows
        while (deque.Count > 0 && nums[deque.Last!.Value] < nums[i])
        {
            deque.RemoveLast();
        }

        // 3. Add current index to deque
        deque.AddLast(i);

        // 4. Add to result when window is complete (i >= k-1)
        //    The front of deque has the index of max element
        if (i >= k - 1)
        {
            result[i - k + 1] = nums[deque.First!.Value];
        }
    }

    return result;
}
```

### Implementation with Detailed Comments

```csharp
public int[] MaxSlidingWindow(int[] nums, int k)
{
    // Edge cases
    if (nums.Length == 0 || k == 0) return Array.Empty<int>();

    // Result array: one max value for each window position
    // Number of windows = nums.Length - k + 1
    int[] result = new int[nums.Length - k + 1];

    // Deque stores INDICES (not values) in monotonic decreasing order
    // Front of deque = index of largest element in current window
    var deque = new LinkedList<int>();

    for (int i = 0; i < nums.Length; i++)
    {
        // STEP 1: Remove indices that are outside the current window
        // Window range: [i-k+1, i]
        // So if deque.First <= i-k, it's outside (too far left)
        while (deque.Count > 0 && deque.First!.Value <= i - k)
        {
            deque.RemoveFirst();
        }

        // STEP 2: Maintain monotonic decreasing order
        // Remove all indices whose values are smaller than current element
        // Why? Because nums[i] is:
        //   a) Larger (so it's better for max)
        //   b) More recent (stays in window longer)
        // Therefore, smaller elements will NEVER be the max again
        while (deque.Count > 0 && nums[deque.Last!.Value] < nums[i])
        {
            deque.RemoveLast();
        }

        // STEP 3: Add current index to back of deque
        deque.AddLast(i);

        // STEP 4: Once window is complete (i >= k-1), record the max
        // The front of deque always contains index of max element
        if (i >= k - 1)
        {
            result[i - k + 1] = nums[deque.First!.Value];
        }
    }

    return result;
}
```

---

## Complexity Analysis

### Time Complexity: O(n)

Each element is:
- **Added once** to the deque
- **Removed at most once** from the deque

Total operations: ≤ 2n → **O(n)**

This is optimal because we must examine each element at least once.

### Space Complexity: O(n)

- Result array: O(n - k + 1) ≈ O(n)
- Deque: O(k) in the worst case (storing k indices)

Overall: **O(n)**

---

## Alternative Solutions

### Naive Approach: O(n*k)

```csharp
// For each window, scan all k elements to find max
public int[] MaxSlidingWindowNaive(int[] nums, int k)
{
    int[] result = new int[nums.Length - k + 1];

    for (int i = 0; i <= nums.Length - k; i++)
    {
        int max = nums[i];
        for (int j = i; j < i + k; j++)
        {
            max = Math.Max(max, nums[j]);
        }
        result[i] = max;
    }

    return result;
}
```

**Problem**: Recalculates max for each window, even when windows overlap by k-1 elements.

### Using Priority Queue: O(n log k)

```csharp
// Use max heap, but need to remove elements outside window
// More complex and slower than deque approach
```

### Dynamic Programming: O(n)

```csharp
// Split array into blocks of size k
// Precompute max from left and right within each block
// Complex implementation, deque is simpler
```

---

## Key Takeaways

1. **Monotonic Deque** maintains elements in sorted order while allowing efficient insertion/deletion from both ends

2. **Store Indices, Not Values** - indices let us check if elements are still in the window

3. **Two-End Operations**:
   - Remove from **front**: Elements outside window
   - Remove from **back**: Smaller elements that will never be max

4. **Decreasing Order**: The front always contains the maximum element's index

5. **O(n) Time**: Each element enters and leaves the deque at most once

---

## Related Problems

- [LeetCode 239 - Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) (This problem)
- [LeetCode 155 - Min Stack](https://leetcode.com/problems/min-stack/) - Similar monotonic concept
- [LeetCode 496 - Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) - Monotonic stack
- [LeetCode 503 - Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/) - Circular monotonic stack
- [LeetCode 239 - Sliding Window Median](https://leetcode.com/problems/sliding-window-median/) - Similar window problem

---

## Implementation Location

**File**: [FixedSlidingWindow.cs](../../src/Playground.ConsoleApp/session-2/SlidingWindow/FixedSlidingWindow.cs#L107)

**Session**: Session 2 - Sliding Window Pattern

**Documentation**: [session-02-content.md](../session-02-content.md#L810-L843)
