# 66. Plus One

## Problem Description

You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

## Examples

### Example 1

**Input:** `digits = [1,2,3]`
**Output:** `[1,2,4]`
**Explanation:** The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4].

### Example 2

**Input:** `digits = [4,3,2,1]`
**Output:** `[4,3,2,2]`
**Explanation:** The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2].

### Example 3

**Input:** `digits = [9]`
**Output:** `[1,0]`
**Explanation:** The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0].

## Constraints

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading 0's

## Solution

### Algorithm Explanation

**Approach:** Reverse iteration with carry propagation

This problem simulates adding 1 to a number represented as an array of digits. The key insight is to iterate from right to left (least significant to most significant digit) and handle the "carry" operation, just like manual addition.

**Steps:**
1. Start from the rightmost digit (least significant)
2. Add 1 to it
3. If the result is less than 10, we're done - just update and return
4. If the result is 10, set current digit to 0 and carry 1 to the next position
5. Continue until no carry remains or we reach the leftmost digit
6. If we still have a carry after processing all digits (e.g., 999 → 1000), create a new array with an extra digit at the front

**Complexity:**
- **Time Complexity:** O(n) where n is the number of digits
- **Space Complexity:** O(1) for in-place modification, O(n) worst case if creating new array for carry

**Edge Cases:**
- Single digit: `[5]` → `[6]`
- All 9's: `[9,9,9]` → `[1,0,0,0]` (requires new array)
- No carry needed: `[1,2,3]` → `[1,2,4]`

### C# Implementation

```csharp
public class C66PlusOne
{
    public int[] PlusOne(int[] digits)
    {
        // Iterate from right to left (least significant to most significant)
        for (int i = digits.Length - 1; i >= 0; i--)
        {
            // If current digit is less than 9, just increment and return
            if (digits[i] < 9)
            {
                digits[i]++;
                return digits;
            }

            // If current digit is 9, it becomes 0 and we carry to the next position
            digits[i] = 0;
        }

        // If we reach here, all digits were 9 (e.g., 999 → 1000)
        // We need a new array with an extra digit
        int[] result = new int[digits.Length + 1];
        result[0] = 1; // Set the first digit to 1
        // All other digits are already 0 (default value for int array)

        return result;
    }
}
```

**Key Insights:**
- We can modify the array in-place for most cases, making it efficient
- The only time we need a new array is when all digits are 9
- When creating a new array for the all-9's case, we only need to set the first element to 1 since all other elements default to 0
- Early return optimisation: as soon as we find a digit less than 9, we can stop and return