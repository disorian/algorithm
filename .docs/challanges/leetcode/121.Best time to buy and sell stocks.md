# 121. Best Time to Buy and Sell Stock

**Problem Link**: <https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/>

## Problem Description

You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.

You want to maximise your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.

## Examples

### Example 1

**Input**: `prices = [7,1,5,3,6,4]`

**Output**: `5`

**Explanation**: Buy on day 2 (price = `1`) and sell on day 5 (price = `6`), profit = `6 - 1 = 5`. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

### Example 2

**Input**: `prices = [7,6,4,3,1]`

**Output**: `0`

**Explanation**: In this case, no transactions are done and the max profit = `0`.

## Constraints

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

## Solution

### Algorithm Explanation

**Approach:** Single-pass tracking of minimum price and maximum profit

This is a classic dynamic programming problem that can be solved optimally in a single pass. The key insight is that for each day, we need to know the minimum price seen so far and calculate the potential profit if we sell on that day.

**Steps:**
1. Initialise `minPrice` to infinity (or a very large value) to track the lowest price encountered
2. Initialise `maxProfit` to `0` since we can't have negative profit (we simply don't trade)
3. Iterate through each price in the array:
   - Update `minPrice` if current price is lower than `minPrice`
   - Calculate potential profit: `currentPrice - minPrice`
   - Update `maxProfit` if current potential profit is greater
4. Return `maxProfit`

**Complexity:**
- **Time Complexity:** O(n) - Single pass through the array
- **Space Complexity:** O(1) - Only using two variables regardless of input size

**Why This Works:**
- We only need to track the minimum price seen so far because buying at the lowest price before the current day gives the maximum profit for selling on the current day
- We update the maximum profit whenever we find a better selling opportunity
- By processing left to right, we ensure we always buy before we sell

**Edge Cases:**
- Single day: `prices = [5]` → `0` (can't buy and sell on the same day)
- Prices always decreasing: `[7,6,4,3,1]` → `0` (no profitable transaction)
- Prices always increasing: `[1,2,3,4,5]` → `4` (buy at 1, sell at 5)
- Best buy is at the beginning: `[1,5,3,6,4]` → `5` (buy at 1, sell at 6)
- Best buy is later: `[7,1,5,3,6,4]` → `5` (buy at 1, sell at 6)

### C# Implementation

```csharp
public class C121BestTimeToBuyAndSellStock
{
    public int MaxProfit(int[] prices)
    {
        // Edge case: empty array or single price
        if (prices == null || prices.Length <= 1)
            return 0;

        int minPrice = int.MaxValue;
        int maxProfit = 0;

        foreach (int price in prices)
        {
            // Update minimum price if current price is lower
            if (price < minPrice)
            {
                minPrice = price;
            }
            // Calculate potential profit and update max profit
            else if (price - minPrice > maxProfit)
            {
                maxProfit = price - minPrice;
            }
        }

        return maxProfit;
    }
}
```

**Key Insights:**
- We don't need to track which specific days to buy and sell, only the maximum profit
- The `else if` optimisation ensures we only calculate profit when the current price is not a new minimum
- Using `int.MaxValue` for initial `minPrice` ensures any real price will be lower
- The algorithm naturally handles the "no profitable transaction" case by returning `0`
- This is a greedy algorithm: at each step, we make the locally optimal choice (tracking minimum buy price) which leads to the globally optimal solution