# 118. Pascal's Triangle

**Problem Link**: <https://leetcode.com/problems/pascals-triangle/description/>

## Problem Description

Given an integer `numRows`, return the first `numRows` of Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

```
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
```

## Examples

### Example 1

**Input**: `numRows = 5`

**Output**: `[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

### Example 2

**Input**: `numRows = 1`

**Output**: `[[1]]`

## Constraints

- `1 <= numRows <= 30`

## Solution

### Algorithm Explanation

**Approach:** Iterative row-by-row construction

Pascal's triangle is a triangular array where each number is the sum of the two numbers directly above it. The key insight is to build the triangle row by row, where each row depends only on the previous row.

**Steps:**
1. Initialise an empty result list to store all rows
2. For each row from 1 to `numRows`:
   - Create a new row starting and ending with `1`
   - For positions between the first and last element:
     - Calculate the value as the sum of two adjacent elements from the previous row
     - `row[j] = previousRow[j-1] + previousRow[j]`
   - Add the completed row to the result
3. Return the complete triangle

**Complexity:**
- **Time Complexity:** O(numRows²) - We generate `numRows` rows, and each row `i` has `i` elements
- **Space Complexity:** O(numRows²) - The output contains approximately `numRows²/2` elements

**Edge Cases:**
- Single row: `numRows = 1` → `[[1]]`
- Two rows: `numRows = 2` → `[[1], [1,1]]`
- Each row always starts and ends with `1`

### C# Implementation

```csharp
public class C118PascalsTriangle
{
    public IList<IList<int>> Generate(int numRows)
    {
        var result = new List<IList<int>>();

        // Edge case: if numRows is 0 or less, return empty list
        if (numRows <= 0)
            return result;

        // First row is always [1]
        result.Add(new List<int> { 1 });

        // Build subsequent rows
        for (int i = 1; i < numRows; i++)
        {
            var currentRow = new List<int>();
            var previousRow = result[i - 1];

            // First element is always 1
            currentRow.Add(1);

            // Middle elements are sum of two elements from previous row
            for (int j = 1; j < i; j++)
            {
                currentRow.Add(previousRow[j - 1] + previousRow[j]);
            }

            // Last element is always 1
            currentRow.Add(1);

            result.Add(currentRow);
        }

        return result;
    }
}
```

**Key Insights:**
- Each row has `rowNumber` elements (row 1 has 1 element, row 2 has 2 elements, etc.)
- The first and last elements of each row are always `1`
- Each interior element is calculated from the previous row: `previousRow[j-1] + previousRow[j]`
- We only need to reference the immediately previous row, making it memory-efficient
- The algorithm naturally handles all edge cases through the loop structure